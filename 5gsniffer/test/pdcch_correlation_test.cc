#include "gtest/gtest.h"
#include "pdcch.h"
#include "dmrs.h"
#include "fftw3.h"
#include "file_source.h"
#include "utils.h"
#include "dsp.h"
#include <numeric>
#include <span>

class pdcch_correlation_test : public ::testing::Test {
 protected:
  pdcch_correlation_test() {
  }

};


TEST_F(pdcch_correlation_test, test_pdcch_dmrs_correlations) {

  uint16_t nid_cell = 102;

  constexpr uint16_t aggregation_level = 4;

  constexpr uint16_t max_aggregation_level = 8;

  int num_candidate = 0;
  int max_num_candidate = 4;
  int numSlot = 9;
  bool user_search_space = false;

  int num_samples = 576;

  std::string samples_dir = "../../test/samples/";
  file_source source(num_samples, samples_dir + "SIB1_Slot1_OFDM1_Matlab.fc32");

  // Buffer for the input source file. It is the SIB1 PDCCH, only the OFDM symbol that contains it. 
  std::vector<complex<float>> sib1_subcarriers;
  sib1_subcarriers.reserve(num_samples);

  shared_ptr<std::vector<std::complex<float>>> p = source.produce_samples(num_samples);
  sib1_subcarriers.insert(sib1_subcarriers.end(), p.get()->begin(), p.get()->end());

  // dump_to_file(string("/tmp/load_matlab_slot1_symbol1"), span<complex<float>>{sib1_subcarriers} );
 
  pdcch pdcch1;
  pdcch pdcch2;
  pdcch pdcch3;

  coreset coreset_info_(0,48,1,"interleaved",6,2,102,102, 0, 14, 10, {8, 4, 2, 1, 0});
  coreset coreset_info_1(0,48,1,"interleaved",2,2,102,102, 0, 14, 10, {8, 4, 2, 1, 0});
  coreset coreset_info_2(0,48,2,"interleaved",6,2,102,102, 0, 14, 10, {8, 4, 2, 1, 0});

  pdcch1.set_coreset_info(coreset_info_);

  pdcch2.set_coreset_info(coreset_info_1);

  pdcch3.set_coreset_info(coreset_info_2);

  std::vector<uint16_t> pdcch_dmrs_rb_indeces4_2_2 = pdcch2.get_rb_interleaved(aggregation_level);

  std::vector<uint16_t> pdcch_dmrs_rb_indeces4_2_2_2 = pdcch3.get_rb_candidates(aggregation_level, num_candidate, max_num_candidate, numSlot, user_search_space);

  std::vector<uint64_t> pdcch_dmrs_indices_al4 = pdcch1.get_dmrs_sc_indices(aggregation_level, num_candidate, max_num_candidate, numSlot, user_search_space);

  std::vector<uint64_t> pdcch_dmrs_indices_al8 = pdcch1.get_dmrs_sc_indices(max_aggregation_level, num_candidate, max_num_candidate, numSlot, user_search_space);

  std::vector<uint16_t> pdcch_dmrs_rb_indeces_p = pdcch1.get_dmrs_rb_indices(aggregation_level, num_candidate, max_num_candidate, numSlot, user_search_space);

  dmrs dmrs_pdcch;

  /*This 2 sequences are actually the same but the second one keeps going longer, I could use only the second one.
  How this works is as follows. You create a sequence with the maximum length based on the PRB indices. For instance, you might have a 
  PDCCH DMRS Ind which is 1 2 3 4... 12 25 26 27 ... 36. So CCE [1 2 5 6]. You create the DMRS to be able to fit for 6 * 18 DMRS, and then you select
  the DMRS with the PDCCH DMRS Ind. e.g. the DMRS corresponding to PRBs [1 2 3 4... 12 25 26 27 ... 36.]
  This PDCCH DMRS Ind are the values of cce indices after interleaving etc and sorting. CCE indices is the output of the CCE candidates, e.g. from Yp, etc.
  For instance, for the Matlab example of SIB1 (generated by Matlab), we have that, for aggregation level 3 (4 CCEs), the candidates are for this aggreg. level are:
  [0 1 2 4] and [4 5 6 7]. The CCE-REG mapping looks like the following before interleaving:

     1     7    13    19    25    31    37    43
     2     8    14    20    26    32    38    44
     3     9    15    21    27    33    39    45
     4    10    16    22    28    34    40    46
     5    11    17    23    29    35    41    47
     6    12    18    24    30    36    42    48

  The interleaving pattern is [6 2 7 3 0 4 1 5]. After interleaving looks as follows:

    37    13    43    19     1    25     7    31
    38    14    44    20     2    26     8    32
    39    15    45    21     3    27     9    33
    40    16    46    22     4    28    10    34
    41    17    47    23     5    29    11    35
    42    18    48    24     6    30    12    36

  For the second Candidate, [4 5 6 7], the RB per CCE Idx looks as follows:

     1    25     7    31
     2    26     8    32
     3    27     9    33
     4    28    10    34
     5    29    11    35
     6    30    12    36

  Which sorted becomes the following PRB indices for the given PDCCH candidate based on the CCE index: [1 2 3 4 5 6 7 8 9 10 11 12 25 26 27 28 29 30 31 32 33 34 35 36]   
  Then, you generate the PDCCH DMRS for 0 to 36 PRBs, which is 6 CCEs, 18 PDCCH DMRS per CEE, 108 PDCCH DMRS. Then, your PDCCH DMRS symbols are only the 
  ones that match the PRB indices.*/

  std::vector<std::complex<float>> pdcch_dmrs_symbols_al4 = {};

  std::vector<std::complex<float>> pdcch_dmrs_symbols_al8 = dmrs_pdcch.generate_pdcch_dmrs_symb(nid_cell, 9 , 0, 14, 2*max_aggregation_level*18);

  std::vector<uint16_t> pdcch_dmrs_rb_indeces = pdcch1.get_dmrs_rb_indices(aggregation_level, num_candidate, max_num_candidate, numSlot, user_search_space);


  for (int i_idx = 0 ; i_idx < pdcch_dmrs_rb_indeces.size(); i_idx++){
    pdcch_dmrs_symbols_al4.push_back(pdcch_dmrs_symbols_al8.at(pdcch_dmrs_rb_indeces.at(i_idx)));
  }

  /*Create REF Grid*/

  std::vector<std::complex<float>> refGrid_AL4(12*pdcch1.get_coreset_info().get_frequency_domain_resources());

  std::vector<std::complex<float>> refGrid_AL8(12*pdcch1.get_coreset_info().get_frequency_domain_resources());

  for (int i_idx = 0 ; i_idx < pdcch_dmrs_indices_al4.size(); i_idx++){
    refGrid_AL4.at(pdcch_dmrs_indices_al4.at(i_idx)) = pdcch_dmrs_symbols_al4.at(i_idx);
  }

  for (int i_idx = 0 ; i_idx < pdcch_dmrs_indices_al8.size(); i_idx++){
    refGrid_AL8.at(pdcch_dmrs_indices_al8.at(i_idx)) = pdcch_dmrs_symbols_al8.at(i_idx);
  }

  std::vector<float> correlation_magnitudes_AL4;
  std::vector<float> correlation_magnitudes_AL8;

  // Adding Zeros before and after sib1_subcarriers to have a moving correlation

  std::vector<complex<float>> sib1_subcarriers_padded(num_samples*2);


  sib1_subcarriers_padded.insert(sib1_subcarriers_padded.begin() + 288, sib1_subcarriers.begin(), sib1_subcarriers.end());

  // Correlate

  correlate_magnitude(correlation_magnitudes_AL4, sib1_subcarriers_padded, {refGrid_AL4.data(), refGrid_AL4.size()});

  // dump_to_file(string("/tmp/correlation_pdcch_dmrs_AL4"), span<float>{correlation_magnitudes_AL4});

  // Correlate

  correlate_magnitude_normalized(correlation_magnitudes_AL8, sib1_subcarriers_padded, {refGrid_AL8.data(), refGrid_AL8.size()});
  
  // dump_to_file(string("/tmp/correlation_pdcch_dmrs_AL8"), span<float>{correlation_magnitudes_AL8});
 
}